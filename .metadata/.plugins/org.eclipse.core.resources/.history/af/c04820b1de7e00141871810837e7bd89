//#include <locale.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
#include "xil_cache.h"
#include "xaxipmon.h"
#include "xuartps.h"
#include "xparameters.h"
#include "ctrl_fifos.h"
#include "my_cf_hdmi_demo.h"
#include "my_cf_hdmi.h"
#include "config.h"
#include "mappings.h"
#include "fifoAllocations.h"

//--- Global variables ---//
u8 refFrmBuff[IMG_LENGTH];

//---Local variables -------//
static unsigned int fileSize = 0;
#if USE_PERF_MON == 1
	static XAxiPmon AxiPmonInst;     						 /* System Monitor driver instance */
	static XAxiPmon AxiPmonInst_00;    						 /* Cluster_1 Monitor_0 driver instance */
	static XAxiPmon AxiPmonInst_01;    						 /* Cluster_1 Monitor_1 driver instance */
	static XAxiPmon AxiPmonInst_10;    						 /* Cluster_2 Monitor_0 driver instance */
	static XAxiPmon AxiPmonInst_11;    						 /* Cluster_2 Monitor_1 driver instance */
//	static XAxiPmon *AxiPmonInstPtr;
#endif

static ctrl_fifo_hdlr input_data_fifo;						/* Fifo for input data */

static ctrl_fifo_hdlr ctrl_fifo_output[NB_PROCESSORS];						/* Control fifos*/
static ctrl_fifo_hdlr ctrl_fifo_input[NB_PROCESSORS];
//static ctrl_fifo_hdlr ctrl_fifo_output_1;
//static ctrl_fifo_hdlr ctrl_fifo_output_2;
//static ctrl_fifo_hdlr ctrl_fifo_output_3;
//static ctrl_fifo_hdlr ctrl_fifo_output_4;
//-------//

//---- External declarations -----//
extern int source_readRefFrm(u8* refFrmBuff);
extern int source_init();
extern unsigned int source_sizeOfFile();
extern int source_readNBytes(unsigned char *outTable, unsigned int nbBytesToRead);
extern void displayYUV_init();
#if ENABLE_TRACES == 1
extern void openTracesFiles();
#endif

extern char inbyte(void);
//-------//


void initMemRegion(int startAddr, int size){
	Xil_DCacheDisable();
	memset((int*)startAddr, 0, size);
	Xil_DCacheEnable();
}

void initCtrlFIFOs(){
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[0], CTRL_FIFO_OUT_0_START_ADDR, CTRL_FIFO_OUT_0_RD_IX_ADDR, CTRL_FIFO_OUT_0_WR_IX_ADDR, CTRL_FIFO_OUT_0_SIZE);
//	init_ctrl_fifo_hdlr(&ctrl_fifo_input[0], 0x40000000, 0x4003D1E8, 0x4003D1EC, CTRL_FIFO_SIZE);
//	init_ctrl_fifo_hdlr(&ctrl_fifo_input[0], CTRL_FIFO_IN_0_START_ADDR, CTRL_FIFO_IN_0_RD_IX_ADDR, CTRL_FIFO_IN_0_WR_IX_ADDR, CTRL_FIFO_IN_0_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[1], CTRL_FIFO_OUT_1_START_ADDR, CTRL_FIFO_OUT_1_RD_IX_ADDR, CTRL_FIFO_OUT_1_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[2], CTRL_FIFO_OUT_2_START_ADDR, CTRL_FIFO_OUT_2_RD_IX_ADDR, CTRL_FIFO_OUT_2_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[3], CTRL_FIFO_OUT_3_START_ADDR, CTRL_FIFO_OUT_3_RD_IX_ADDR, CTRL_FIFO_OUT_3_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[4], CTRL_FIFO_OUT_4_START_ADDR, CTRL_FIFO_OUT_4_RD_IX_ADDR, CTRL_FIFO_OUT_4_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[5], CTRL_FIFO_OUT_5_START_ADDR, CTRL_FIFO_OUT_5_RD_IX_ADDR, CTRL_FIFO_OUT_5_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[6], CTRL_FIFO_OUT_6_START_ADDR, CTRL_FIFO_OUT_6_RD_IX_ADDR, CTRL_FIFO_OUT_6_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[7], CTRL_FIFO_OUT_7_START_ADDR, CTRL_FIFO_OUT_7_RD_IX_ADDR, CTRL_FIFO_OUT_7_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[8], CTRL_FIFO_OUT_8_START_ADDR, CTRL_FIFO_OUT_8_RD_IX_ADDR, CTRL_FIFO_OUT_8_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[9], CTRL_FIFO_OUT_9_START_ADDR, CTRL_FIFO_OUT_9_RD_IX_ADDR, CTRL_FIFO_OUT_9_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[10], CTRL_FIFO_OUT_10_START_ADDR, CTRL_FIFO_OUT_10_RD_IX_ADDR, CTRL_FIFO_OUT_10_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[11], CTRL_FIFO_OUT_11_START_ADDR, CTRL_FIFO_OUT_11_RD_IX_ADDR, CTRL_FIFO_OUT_11_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[12], CTRL_FIFO_OUT_12_START_ADDR, CTRL_FIFO_OUT_12_RD_IX_ADDR, CTRL_FIFO_OUT_12_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[13], CTRL_FIFO_OUT_13_START_ADDR, CTRL_FIFO_OUT_13_RD_IX_ADDR, CTRL_FIFO_OUT_13_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[14], CTRL_FIFO_OUT_14_START_ADDR, CTRL_FIFO_OUT_14_RD_IX_ADDR, CTRL_FIFO_OUT_14_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[15], CTRL_FIFO_OUT_15_START_ADDR, CTRL_FIFO_OUT_15_RD_IX_ADDR, CTRL_FIFO_OUT_15_WR_IX_ADDR, CTRL_FIFO_STANDARD_SIZE);

	// init input data fifo.
	init_ctrl_fifo_hdlr(&input_data_fifo, INPUT_FILE_START_ADDR, INPUT_FILE_RD_IX_ADDR, INPUT_FILE_WR_IX_ADDR, INPUT_FILE_SIZE);
}

int copyVData(int bytesToCopy){
	return source_readNBytes(input_data_fifo.fifo.contents, bytesToCopy);
}

int writeData(){
	int bytesRead;
	int bytesToCopy;

	fileSize = source_sizeOfFile();
	bytesToCopy = fileSize;

//	do {
//		rd_ctrl_fifo(&ctrl_fifo_output[0]);
//	} while (1 > ctrl_fifo_output[0].fifo.size - ctrl_fifo_output[0].ctrl_fifo_wr_ix + ctrl_fifo_output[0].ctrl_fifo_rd_ix);

	while(bytesToCopy > rd_ctrl_fifo_nb_free(&input_data_fifo));

	bytesRead = copyVData(bytesToCopy);
	if(bytesRead == bytesToCopy){
		input_data_fifo.fifo.write_ind[0] += bytesRead;
	}
	return bytesRead;
}

/*
 * Initialize AXI Performance Monitor.
 */
int init_apm(XAxiPmon *AxiPmonInstPtr, u16 DeviceID, u8 Metric)
{
	int Status;
	XAxiPmon_Config *ConfigPtr;
	u8 SlotId = 0x0;

	ConfigPtr = XAxiPmon_LookupConfig(DeviceID);
	if (ConfigPtr == NULL) {
		return XST_FAILURE;
	}

	XAxiPmon_CfgInitialize(AxiPmonInstPtr, ConfigPtr, ConfigPtr->BaseAddress);

//	XAxiPmon_EnableIDFilter(AxiPmonInstPtr);
	XAxiPmon_DisableIDFilter(AxiPmonInstPtr);

	/*
	 * Self Test the System Monitor/ADC device
	 */
	Status = XAxiPmon_SelfTest(AxiPmonInstPtr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Select Agent and required set of Metrics for a Counter.
	 * We can select another agent,Metrics for another counter by
	 * calling below function again.
	 */
	for (SlotId = 0; SlotId < ConfigPtr->NumberofSlots; SlotId++) {
		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, Metric, SlotId);
//		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, XAPM_METRIC_SET_1, XAPM_METRIC_COUNTER_1);
//		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, XAPM_METRIC_SET_2, XAPM_METRIC_COUNTER_2);
//		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, XAPM_METRIC_SET_3, XAPM_METRIC_COUNTER_3);
	}


	/*
	 * Enable interrupts and if APM_1
	 */
//	if(DeviceID == XPAR_MBCLUSTER1_AXI_PERF_MON_0_DEVICE_ID){
//		XAxiPmon_IntrGlobalEnable(AxiPmonInstPtr);									// Enable Global Interrupt.
//		XAxiPmon_WriteReg(AxiPmonInstPtr->Config.BaseAddress, XAPM_IE_OFFSET, 2);	// Enable Sample Interval Counter Overflow Interrupt.
//		XAxiPmon_SetSampleInterval(AxiPmonInstPtr, 10000000); 						// Write the load value in the Sample Interval Register (1 s).
//		XAxiPmon_WriteReg(AxiPmonInstPtr->Config.BaseAddress, XAPM_SICR_OFFSET, 2);	// Set the Load bit in the Sample Interval Control Register.
//		XAxiPmon_EnableSampleIntervalCounter(AxiPmonInstPtr);						// Enable the Sample Interval Counter.
//	}

	/*
	 * Enable Metric Counters.
	 */
	XAxiPmon_EnableMetricsCounter(AxiPmonInstPtr);

	/*
	 * Enable Global Clock Counter Register.
	 */
	XAxiPmon_EnableGlobalClkCounter(AxiPmonInstPtr);

	return XST_SUCCESS;

}


void readPerfMonitor(XAxiPmon *AxiPmonInstPtr,
					u32 Metrics[],
					u32 *ClkCntHigh,
					u32 *ClkCntLow){

	u8 SlotId = 0x0;
	/*
	 * Disable Global Clock Counter Register.
	 */

	XAxiPmon_DisableGlobalClkCounter(AxiPmonInstPtr);

	/*
	 * Disable Metric Counters.
	 */
//	XAxiPmon_DisableMetricsCounter(AxiPmonInstPtr);

	/* Get Metric Counters  */
	for (SlotId = 0; SlotId < AxiPmonInstPtr->Config.NumberofSlots; SlotId++) {
		Metrics[SlotId] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, SlotId);
//		Metrics[SlotId][1] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, XAPM_METRIC_COUNTER_1);
//		Metrics[SlotId][2] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, XAPM_METRIC_COUNTER_2);
//		Metrics[SlotId][3] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, XAPM_METRIC_COUNTER_3);

//		Incrementers[SlotId][0] = XAxiPmon_GetIncrementer(AxiPmonInstPtr, XAPM_INCREMENTER_0);
	}

	/* Get Global Clock Cycles Count in ClkCntHigh,ClkCntLow */
	XAxiPmon_GetGlobalClkCounter(AxiPmonInstPtr, ClkCntHigh, ClkCntLow);


}


void printMetricValues(XAxiPmon *AxiPmonInstPtr, u8 nbSlots, u8 Metric){
	u8 SlotId;
	u32 ClkCntHigh;
	u32 ClkCntLow;
	u32 Metrics[MAX_NUM_MONITOR_SLOTS] = {0};

	readPerfMonitor(AxiPmonInstPtr, Metrics, &ClkCntHigh, &ClkCntLow);
	for (SlotId = 0; SlotId < nbSlots; SlotId++) {
//		xil_printf("***APM_%d***\r\n", AxiPmonInstPtr->Config.DeviceId);
		xil_printf("%s for slot %d : %d\r\n", XAxiPmon_GetMetricName(Metric), SlotId, Metrics[SlotId]);
	}
}


void dynamicMapping(unsigned int nbProcessors){
	int i, j;
	int tempSchedCaller[NB_ACTORS];
	int cntr = 0;
	for (i = 0; i < nbProcessors; i++) { // Skips processor 0 which always executes Source & Display.
		cntr = 0;
		for (j = 0; j < NB_ACTORS; j++) {
			if(mapping[nbProcessors - 1][i][j] == true){
				tempSchedCaller[cntr] = schedCallerAddr[j];
				cntr++;
			}
		}
		push_contents_ctrl_fifo_blocking(&ctrl_fifo_output[i], (unsigned char*)tempSchedCaller, cntr * sizeof(int));
	}
}

unsigned char changeMapping(void)
{
	char receivedChar = 0;

	if(XUartPs_IsReceiveData(UART_BASEADDR))
	{
		receivedChar = inbyte();
		if((receivedChar == 0x32) || (receivedChar == 0x34) || (receivedChar == 0x38))
		{
			xil_printf("Mapping to %c processors\n\r", receivedChar);
			dynamicMapping(receivedChar - 0x30);
			return 1;
		}
	}
	return 0;
}

int main(int argc, char *argv[]){

	u16 nbFrm = 0;
	u8* decPictureBuffer;

	/* Initializing control FIFOs */
	initCtrlFIFOs();

#if ENABLE_FIFOS_COPY == 1
	initMemRegion(FIFOS_COPY_BUFFS_START_ADDR, sizeof(FIFOS_COPY_BUFF)*NB_FIFOS);
#endif

#if ENABLE_START_SIGNAL == 1
#if DDR_DATA_FIFO == 1
	/* Initializing memory region for data fifos */
	initMemRegion(DDR_DATA_FIFO_START, DDR_DATA_FIFO_SIZE);
#endif

	/* Sending start signal to all slave processors */
	if(sendStartSignalToAll() > 0) return -1;
#endif

#if USE_PERF_MON == 1
	int Status;
	/* Initializing the AXI Performance Monitors*/

//	Status = init_apm(&AxiPmonInst, XPAR_AXI_PERF_MON_0_DEVICE_ID, XAPM_METRIC_SET_0);
//	if (Status != XST_SUCCESS) {
//		xil_printf("APM System initialization failed.\r\n");
//		return XST_FAILURE;
//	}
//	XAxiPmon_SetMetrics(&AxiPmonInst, 0, XAPM_METRIC_SET_1, 2);
//	XAxiPmon_SetMetrics(&AxiPmonInst, 1, XAPM_METRIC_SET_1, 3);


	Status = init_apm(&AxiPmonInst_00, XPAR_AXIPMON_0_DEVICE_ID, XAPM_METRIC_SET_1);
	if (Status != XST_SUCCESS) {
		xil_printf("APM_0 Cluster_1 initialization failed.\r\n");
		return XST_FAILURE;
	}
	Status = init_apm(&AxiPmonInst_10, XPAR_AXIPMON_2_DEVICE_ID, XAPM_METRIC_SET_1);
	if (Status != XST_SUCCESS) {
		xil_printf("APM_0 Cluster_2 initialization failed.\r\n");
		return XST_FAILURE;
	}
//	Status = init_apm(&AxiPmonInst_01, XPAR_MBCLUSTER1_AXI_PERF_MON_1_DEVICE_ID, XAPM_METRIC_SET_1);
//	if (Status != XST_SUCCESS) {
//		xil_printf("APM_1 Cluster_1 initialization failed.\r\n");
//		return XST_FAILURE;
//	}
//	Status = init_apm(&AxiPmonInst_11, XPAR_MBCLUSTER2_AXI_PERF_MON_1_DEVICE_ID, XAPM_METRIC_SET_1);
//	if (Status != XST_SUCCESS) {
//		xil_printf("APM_1 Cluster_2 initialization failed.\r\n");
//		return XST_FAILURE;
//	}
	/*****/
#endif


	/* Initializes the SD card controller and opens the encoded video file */
	int result = source_init();

	/* Initializes the HDMI controller system */
	displayYUV_init();

#if ENABLE_TRACES == 1
	openTracesFiles();
#endif

	if(result == 0){
		/* Writing encoded data into microblaze 0 local memory*/
		result = writeData();
		xil_printf("%d bytes of %d were copied.\n\r", input_data_fifo.fifo.write_ind[0], fileSize);
	}

		init_mappings();
		initSchedCallerAddr();
		dynamicMapping(1); // Parameter nbProc; Mapping nbProc - 1, nbProc processors.

	// Waits for data in the input control FIFO, i.e. a decoded image.
	while(1){
//		if(changeMapping()){
//			#if USE_PERF_MON == 1
//				// Print metric values for each slot on PMon 00
//				printMetricValues(&AxiPmonInst_00, XPAR_AXIPMON_0_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_0);
//
//				// Print metric values for each slot on PMon 10
//				printMetricValues(&AxiPmonInst_10, XPAR_AXIPMON_1_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_0);
//
//			//	// Print metric values for each slot on PMon 01
//			//	printMetricValues(&AxiPmonInst_01, XPAR_AXIPMON_2_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);
//			//
//			//	// Print metric values for each slot on PMon 11
//			//	printMetricValues(&AxiPmonInst_11, XPAR_AXIPMON_3_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);
//			//	/******/
//			#endif
//		}
		printFifoIndices(XPAR_CPU_ID);
//		cmpFifosWithTraces();
		#if USE_PERF_MON == 1
			// Print metric values for each slot on PMon 00
			printMetricValues(&AxiPmonInst_00, XPAR_AXIPMON_0_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);

			// Print metric values for each slot on PMon 10
			printMetricValues(&AxiPmonInst_10, XPAR_AXIPMON_1_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);

		//	// Print metric values for each slot on PMon 01
		//	printMetricValues(&AxiPmonInst_01, XPAR_AXIPMON_2_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);
		//
		//	// Print metric values for each slot on PMon 11
		//	printMetricValues(&AxiPmonInst_11, XPAR_AXIPMON_3_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);
		//	/******/
		#endif
//		while(rd_ctrl_fifo_nb_elements(&ctrl_fifo_input[0]) == 0);
//
//		source_readRefFrm(refFrmBuff);	// Read frame from reference file.
//		if(rd_ctrl_fifo_nb_elements(&ctrl_fifo_input[0]) >= IMG_LENGTH){
////				pictureBuffer = &ctrl_fifo_input[0].fifo.contents[ctrl_fifo_input[0].ctrl_fifo_rd_ix % ctrl_fifo_input[0].fifo.size];
//			decPictureBuffer = pop_ctrl_fifo_contents(&ctrl_fifo_input[0]); // Points to the contents of FIFO_0 where the image was stored.
//			DDRVideoWr(decPictureBuffer); // Copy image into the video IP frame buffer.
////				DDRVideoWr(refFrmBuff);
//			nbFrm++; // Counts the number of frames.
//			xil_printf("%d\r\n", nbFrm);
//		}
	}

	return 0;
}

//#include <locale.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
#include "xil_cache.h"
#include "xaxipmon.h"
#include "xparameters.h"
#include "ctrl_fifos.h"
#include "my_cf_hdmi_demo.h"
#include "my_cf_hdmi.h"
#include "config.h"

//--- Global variables ---//
u8 refFrmBuff[IMG_LENGTH];

//---Local variables -------//
static unsigned int fileSize = 0;
#if USE_PERF_MON == 1
	static XAxiPmon AxiPmonInst;     						 /* System Monitor driver instance */
	static XAxiPmon AxiPmonInst_00;    						 /* Cluster_1 Monitor_0 driver instance */
	static XAxiPmon AxiPmonInst_01;    						 /* Cluster_1 Monitor_1 driver instance */
	static XAxiPmon AxiPmonInst_10;    						 /* Cluster_2 Monitor_0 driver instance */
	static XAxiPmon AxiPmonInst_11;    						 /* Cluster_2 Monitor_1 driver instance */
//	static XAxiPmon *AxiPmonInstPtr;
#endif

static ctrl_fifo_hdlr ctrl_fifo_output_0;						/* Control fifos*/
static ctrl_fifo_hdlr ctrl_fifo_input_0;
//-------//

//---- External declarations -----//
extern int source_readRefFrm(u8* refFrmBuff);
extern int source_init();
extern unsigned int source_sizeOfFile();
extern int source_readNBytes(unsigned char *outTable, unsigned int nbBytesToRead);
extern void displayYUV_init();
#if ENABLE_TRACES == 1
extern void openTracesFiles();
#endif

//-------//


void initMemRegion(int startAddr, int size){
	Xil_DCacheDisable();
	memset((int*)startAddr, 0, size);
	Xil_DCacheEnable();
}

int copyVData(int bytesToCopy){
	return source_readNBytes(ctrl_fifo_output_0.fifo.contents, bytesToCopy);
}

int writeData(){
	int bytesRead;
	int bytesToCopy;

	fileSize = source_sizeOfFile();
	bytesToCopy = fileSize;

	do {
		rd_ctrl_fifo(&ctrl_fifo_output_0);
	} while (1 > ctrl_fifo_output_0.fifo.size - ctrl_fifo_output_0.ctrl_fifo_wr_ix + ctrl_fifo_output_0.ctrl_fifo_rd_ix);
	bytesRead = copyVData(bytesToCopy);
	if(bytesRead == bytesToCopy){
		ctrl_fifo_output_0.ctrl_fifo_wr_ix += bytesRead;
		updt_wr_ix(&ctrl_fifo_output_0);
	}
	return bytesRead;
}

/*
 * Initialize AXI Performance Monitor.
 */
int init_apm(XAxiPmon *AxiPmonInstPtr, u16 DeviceID, u8 Metric)
{
	int Status;
	XAxiPmon_Config *ConfigPtr;
	u8 SlotId = 0x0;

	/*
	 * Initialize the cluster_1's AxiPmon driver.
	 */
	ConfigPtr = XAxiPmon_LookupConfig(DeviceID);
	if (ConfigPtr == NULL) {
		return XST_FAILURE;
	}

	XAxiPmon_CfgInitialize(AxiPmonInstPtr, ConfigPtr, ConfigPtr->BaseAddress);

//	XAxiPmon_EnableIDFilter(AxiPmonInstPtr);
	XAxiPmon_DisableIDFilter(AxiPmonInstPtr);

	/*
	 * Self Test the System Monitor/ADC device
	 */
	Status = XAxiPmon_SelfTest(AxiPmonInstPtr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Select Agent and required set of Metrics for a Counter.
	 * We can select another agent,Metrics for another counter by
	 * calling below function again.
	 */
	for (SlotId = 0; SlotId < ConfigPtr->NumberofSlots; SlotId++) {
		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, Metric, SlotId);
//		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, XAPM_METRIC_SET_1, XAPM_METRIC_COUNTER_1);
//		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, XAPM_METRIC_SET_2, XAPM_METRIC_COUNTER_2);
//		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, XAPM_METRIC_SET_3, XAPM_METRIC_COUNTER_3);
	}


	/*
	 * Enable interrupts and if APM_1
	 */
	if(DeviceID == XPAR_MBCLUSTER1_AXI_PERF_MON_0_DEVICE_ID){
		XAxiPmon_IntrGlobalEnable(AxiPmonInstPtr);									// Enable Global Interrupt.
		XAxiPmon_WriteReg(AxiPmonInstPtr->Config.BaseAddress, XAPM_IE_OFFSET, 2);	// Enable Sample Interval Counter Overflow Interrupt.
		XAxiPmon_SetSampleInterval(AxiPmonInstPtr, 10000000); 						// Write the load value in the Sample Interval Register (1 s).
		XAxiPmon_WriteReg(AxiPmonInstPtr->Config.BaseAddress, XAPM_SICR_OFFSET, 2);	// Set the Load bit in the Sample Interval Control Register.
		XAxiPmon_EnableSampleIntervalCounter(AxiPmonInstPtr);						// Enable the Sample Interval Counter.
	}

	/*
	 * Enable Metric Counters.
	 */
	XAxiPmon_EnableMetricsCounter(AxiPmonInstPtr);

	/*
	 * Enable Global Clock Counter Register.
	 */
	XAxiPmon_EnableGlobalClkCounter(AxiPmonInstPtr);

	return XST_SUCCESS;

}


void readPerfMonitor(XAxiPmon *AxiPmonInstPtr,
					u32 Metrics[],
					u32 *ClkCntHigh,
					u32 *ClkCntLow){

	u8 SlotId = 0x0;
	/*
	 * Disable Global Clock Counter Register.
	 */

	XAxiPmon_DisableGlobalClkCounter(AxiPmonInstPtr);

	/*
	 * Disable Metric Counters.
	 */
	XAxiPmon_DisableMetricsCounter(AxiPmonInstPtr);

	/* Get Metric Counters  */
	for (SlotId = 0; SlotId < AxiPmonInstPtr->Config.NumberofSlots; SlotId++) {
		Metrics[SlotId] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, SlotId);
//		Metrics[SlotId][1] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, XAPM_METRIC_COUNTER_1);
//		Metrics[SlotId][2] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, XAPM_METRIC_COUNTER_2);
//		Metrics[SlotId][3] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, XAPM_METRIC_COUNTER_3);

//		Incrementers[SlotId][0] = XAxiPmon_GetIncrementer(AxiPmonInstPtr, XAPM_INCREMENTER_0);
	}

	/* Get Global Clock Cycles Count in ClkCntHigh,ClkCntLow */
	XAxiPmon_GetGlobalClkCounter(AxiPmonInstPtr, ClkCntHigh, ClkCntLow);


}


void printMetricValues(XAxiPmon *AxiPmonInstPtr, u8 nbSlots, u8 Metric){
	u8 SlotId;
	u32 ClkCntHigh;
	u32 ClkCntLow;
	u32 Metrics[MAX_NUM_MONITOR_SLOTS] = {0};

	readPerfMonitor(AxiPmonInstPtr, Metrics, &ClkCntHigh, &ClkCntLow);
	for (SlotId = 0; SlotId < nbSlots; SlotId++) {
//		xil_printf("***APM_%d***\r\n", AxiPmonInstPtr->Config.DeviceId);
		xil_printf("%s for slot %d : %d\r\n", XAxiPmon_GetMetricName(Metric), SlotId, Metrics[SlotId]);
	}
}




int main(int argc, char *argv[]){

	u16 nbFrm = 0;
	u8* decPictureBuffer;

	/* Initializes the HDMI controller system */
	displayYUV_init();

	/* Initializing control FIFOs */
	init_ctrl_fifo_hdlr(&ctrl_fifo_output_0, CTRL_FIFO_OUT_0_START_ADDR, CTRL_FIFO_OUT_0_RD_IX_ADDR, CTRL_FIFO_OUT_0_WR_IX_ADDR, CTRL_FIFO_OUT_0_SIZE);
//	init_ctrl_fifo_hdlr(&ctrl_fifo_input_0, 0x40000000, 0x4003D1E8, 0x4003D1EC, CTRL_FIFO_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input_0, CTRL_FIFO_IN_0_START_ADDR, CTRL_FIFO_IN_0_RD_IX_ADDR, CTRL_FIFO_IN_0_WR_IX_ADDR, CTRL_FIFO_IN_0_SIZE);

#if DDR_DATA_FIFO == 1
	/* Initializing memory region for data fifos */
	initMemRegion(DDR_DATA_FIFO_START, DDR_DATA_FIFO_SIZE);
#endif

#if USE_PERF_MON == 1
	int Status;
	/* Initializing the AXI Performance Monitors*/

	Status = init_apm(&AxiPmonInst, XPAR_AXI_PERF_MON_0_DEVICE_ID, XAPM_METRIC_SET_0);
	if (Status != XST_SUCCESS) {
		xil_printf("APM System initialization failed.\r\n");
		return XST_FAILURE;
	}
	XAxiPmon_SetMetrics(&AxiPmonInst, 0, XAPM_METRIC_SET_1, 2);
	XAxiPmon_SetMetrics(&AxiPmonInst, 1, XAPM_METRIC_SET_1, 3);


	Status = init_apm(&AxiPmonInst_00, XPAR_MBCLUSTER1_AXI_PERF_MON_0_DEVICE_ID, XAPM_METRIC_SET_0);
	if (Status != XST_SUCCESS) {
		xil_printf("APM_0 Cluster_1 initialization failed.\r\n");
		return XST_FAILURE;
	}
	Status = init_apm(&AxiPmonInst_10, XPAR_MBCLUSTER2_AXI_PERF_MON_0_DEVICE_ID, XAPM_METRIC_SET_0);
	if (Status != XST_SUCCESS) {
		xil_printf("APM_0 Cluster_2 initialization failed.\r\n");
		return XST_FAILURE;
	}
	Status = init_apm(&AxiPmonInst_01, XPAR_MBCLUSTER1_AXI_PERF_MON_1_DEVICE_ID, XAPM_METRIC_SET_1);
	if (Status != XST_SUCCESS) {
		xil_printf("APM_1 Cluster_1 initialization failed.\r\n");
		return XST_FAILURE;
	}
	Status = init_apm(&AxiPmonInst_11, XPAR_MBCLUSTER2_AXI_PERF_MON_1_DEVICE_ID, XAPM_METRIC_SET_1);
	if (Status != XST_SUCCESS) {
		xil_printf("APM_1 Cluster_2 initialization failed.\r\n");
		return XST_FAILURE;
	}
	/*****/
#endif


	/* Initializes the SD card controller and opens input file */
	int result = source_init();

#if ENABLE_TRACES == 1
	openTracesFiles();
#endif

	if(result == 0){
		/* Writing data into microblaze 0 local memory*/
		result = writeData();
		xil_printf("%d bytes of %d were copied.\n\r", ctrl_fifo_output_0.fifo.write_ind[0], fileSize);

		// Waits for data in the input control FIFO, i.e. a decoded image.
		while(1){
			do{
				rd_ctrl_fifo(&ctrl_fifo_input_0);
			}while((ctrl_fifo_input_0.ctrl_fifo_num_tkn - ctrl_fifo_input_0.ctrl_fifo_rd_ix) == 0);


			source_readRefFrm(refFrmBuff);	// Read frame from decoded file.
			if((ctrl_fifo_input_0.ctrl_fifo_num_tkn - ctrl_fifo_input_0.ctrl_fifo_rd_ix) >= IMG_LENGTH){
//				pictureBuffer = &ctrl_fifo_input_0.fifo.contents[ctrl_fifo_input_0.ctrl_fifo_rd_ix % ctrl_fifo_input_0.fifo.size];
				decPictureBuffer = (u8*)ctrl_fifo_input_0.fifo.contents;
				DDRVideoWr(decPictureBuffer);
				ctrl_fifo_input_0.ctrl_fifo_rd_ix += IMG_LENGTH;
				updt_rd_ix(&ctrl_fifo_input_0);
				nbFrm++;
//				xil_printf("%d\r\n", nbFrm);
			}else{

//					DDRVideoWr(refFrmBuff);
//					nbFrm++;
//
//					// Empty the input FIFO by moving forwoard the rd index END_FLAG_SIZE times.
//					ctrl_fifo_input_0.ctrl_fifo_rd_ix += END_FLAG_SIZE;
//					updt_rd_ix(&ctrl_fifo_input_0);
//
////					// Advance the wr index so that the microblaze 0 restart reading the input file.
////					ctrl_fifo_output_0.ctrl_fifo_wr_ix += fileSize;
////					updt_wr_ix(&ctrl_fifo_output_0);
			}
#if USE_PERF_MON == 1

			if(nbFrm == 30){
//				if(XAxiPmon_ReadReg(XPAR_MBCLUSTER1_AXI_PERF_MON_0_BASEADDR, XAPM_IS_OFFSET) == 0x2){
//				if((nbFrm == 24) || (nbFails == 90000)){
	//					xil_printf("%d frames decoded\r\n", nbFrm);
					/*** Print metric values for each slot on PMon system ***/
			//		printMetricValues(AxiPmonInst_00, nbslots, Metrics, &ClkCntHigh, &ClkCntLow);
			//		readPerfMonitor(AxiPmonInstPtr, Incrementers, Metrics, &ClkCntHigh, &ClkCntLow);
			//		for (SlotId = 0; SlotId < XPAR_AXIPMON_2_NUM_MONITOR_SLOTS; SlotId++) {
			//			xil_printf("***APM_%d***\r\n", AxiPmonInstPtr->Config.DeviceId);
			//			xil_printf("%s : %d\r\n", XAxiPmon_GetMetricName(XAPM_METRIC_SET_1), Metrics[SlotId]);
			//		}

					// Print metric values for each slot on PMon 00
					printMetricValues(&AxiPmonInst_00, XPAR_AXIPMON_0_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_0);

					// Print metric values for each slot on PMon 10
					printMetricValues(&AxiPmonInst_10, XPAR_AXIPMON_1_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_0);

					// Print metric values for each slot on PMon 01
					printMetricValues(&AxiPmonInst_01, XPAR_AXIPMON_2_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);

					// Print metric values for each slot on PMon 11
					printMetricValues(&AxiPmonInst_11, XPAR_AXIPMON_3_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);
					/******/


//				}
			}
#endif
		}
	}

	return 0;
}

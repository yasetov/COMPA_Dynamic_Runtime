//#include <locale.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
#include "xil_cache.h"
#include "xaxipmon.h"
#include "xuartps.h"
#include "xtmrctr.h"
#include "xparameters.h"
#include "ff.h"
#include "my_cf_hdmi_demo.h"
#include "my_cf_hdmi.h"
#include "config.h"
#include "mappings.h"
#include "fifoAllocations.h"
#include "ctrl_fifos.h"
#include "ctrl_fifo_definitions.h"
#include "compa_trace.h"


//--- Global variables ---//
u8 refFrmBuff[IMG_LENGTH];
int currNbProc = 8;
int prevNbProc;

//---Local variables -------//
static unsigned int fileSize = 0;
#if USE_PERF_MON == 1
	static XAxiPmon AxiPmonInst;     						 /* System Monitor driver instance */
	static XAxiPmon AxiPmonInst_00;    						 /* Cluster_1 Monitor_0 driver instance */
	static XAxiPmon AxiPmonInst_01;    						 /* Cluster_1 Monitor_1 driver instance */
	static XAxiPmon AxiPmonInst_10;    						 /* Cluster_2 Monitor_0 driver instance */
	static XAxiPmon AxiPmonInst_11;    						 /* Cluster_2 Monitor_1 driver instance */
//	static XAxiPmon *AxiPmonInstPtr;
#endif

static ctrl_fifo_hdlr input_data;						/* Fifo for input data */

static ctrl_fifo_hdlr ctrl_fifo_output[NB_PROCESSORS];						/* Control fifos*/
static ctrl_fifo_hdlr ctrl_fifo_input[NB_PROCESSORS];
//static ctrl_fifo_hdlr ctrl_fifo_output_1;
//static ctrl_fifo_hdlr ctrl_fifo_output_2;
//static ctrl_fifo_hdlr ctrl_fifo_output_3;
//static ctrl_fifo_hdlr ctrl_fifo_output_4;

// Timer
XTmrCtr xtimer[NB_PROCESSORS];
XTmrCtr* TmrCtrInstancePtr[NB_PROCESSORS];

//-------//

//---- External declarations -----//
//extern int source_readRefFrm(u8* refFrmBuff);
extern void source_init();
extern void source_close();
//extern unsigned int source_sizeOfFile();
//extern int source_readNBytes(unsigned char *outTable, unsigned int nbBytesToRead);
extern void initHDMI();
//extern char inbyte(void);
//-------//


void initMemRegion(int startAddr, int size){
	Xil_DCacheDisable();
	memset((int*)startAddr, 0, size);
	Xil_DCacheEnable();
}

void initTimers(){
	int i, Status;
	// Initializing handlers.
	for (i = 0; i < NB_PROCESSORS; i++) {
		TmrCtrInstancePtr[i] = &xtimer[i];
	}
	// Initialize device and link it to a handler. Ok if the device was already initialized by the µblaze.
	Status = XTmrCtr_Initialize(TmrCtrInstancePtr[0], XPAR_TMRCTR_0_DEVICE_ID);
	if ((Status != XST_SUCCESS) || (Status != XST_DEVICE_IS_STARTED)) {
//		TODO: ..handle error
	}
	Status = XTmrCtr_Initialize(TmrCtrInstancePtr[1], XPAR_TMRCTR_1_DEVICE_ID);
	if ((Status != XST_SUCCESS) || (Status != XST_DEVICE_IS_STARTED)) {
//		TODO: ..handle error
	}
	Status = XTmrCtr_Initialize(TmrCtrInstancePtr[2], XPAR_TMRCTR_2_DEVICE_ID);
	if ((Status != XST_SUCCESS) || (Status != XST_DEVICE_IS_STARTED)) {
//		TODO: ..handle error
	}
	// TODO: ..init others..
}

void initCtrlFIFOs(){
	init_ctrl_fifo_hdlr(&ctrl_fifo_output[0], CTRL_FIFO_OUT_0_START_ADDR, CTRL_FIFO_OUT_0_RD_IX_ADDR, CTRL_FIFO_OUT_0_WR_IX_ADDR, CTRL_FIFO_OUT_0_SIZE);
//	init_ctrl_fifo_hdlr(&ctrl_fifo_input[0], 0x40000000, 0x4003D1E8, 0x4003D1EC, CTRL_FIFO_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[0], CTRL_FIFO_IN_0_START_ADDR, CTRL_FIFO_IN_0_RD_IX_ADDR, CTRL_FIFO_IN_0_WR_IX_ADDR, CTRL_FIFO_IN_0_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[1], CTRL_FIFO_OUT_1_START_ADDR, CTRL_FIFO_OUT_1_RD_IX_ADDR, CTRL_FIFO_OUT_1_WR_IX_ADDR, CTRL_FIFO_OUT_1_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[1], CTRL_FIFO_IN_1_START_ADDR, CTRL_FIFO_IN_1_RD_IX_ADDR, CTRL_FIFO_IN_1_WR_IX_ADDR, CTRL_FIFO_IN_1_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[2], CTRL_FIFO_OUT_2_START_ADDR, CTRL_FIFO_OUT_2_RD_IX_ADDR, CTRL_FIFO_OUT_2_WR_IX_ADDR, CTRL_FIFO_OUT_2_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[2], CTRL_FIFO_IN_2_START_ADDR, CTRL_FIFO_IN_2_RD_IX_ADDR, CTRL_FIFO_IN_2_WR_IX_ADDR, CTRL_FIFO_IN_2_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[3], CTRL_FIFO_OUT_3_START_ADDR, CTRL_FIFO_OUT_3_RD_IX_ADDR, CTRL_FIFO_OUT_3_WR_IX_ADDR, CTRL_FIFO_OUT_3_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[3], CTRL_FIFO_IN_3_START_ADDR, CTRL_FIFO_IN_3_RD_IX_ADDR, CTRL_FIFO_IN_3_WR_IX_ADDR, CTRL_FIFO_IN_3_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[4], CTRL_FIFO_OUT_4_START_ADDR, CTRL_FIFO_OUT_4_RD_IX_ADDR, CTRL_FIFO_OUT_4_WR_IX_ADDR, CTRL_FIFO_OUT_4_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[4], CTRL_FIFO_IN_4_START_ADDR, CTRL_FIFO_IN_4_RD_IX_ADDR, CTRL_FIFO_IN_4_WR_IX_ADDR, CTRL_FIFO_IN_4_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[5], CTRL_FIFO_OUT_5_START_ADDR, CTRL_FIFO_OUT_5_RD_IX_ADDR, CTRL_FIFO_OUT_5_WR_IX_ADDR, CTRL_FIFO_OUT_5_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[5], CTRL_FIFO_IN_5_START_ADDR, CTRL_FIFO_IN_5_RD_IX_ADDR, CTRL_FIFO_IN_5_WR_IX_ADDR, CTRL_FIFO_IN_5_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[6], CTRL_FIFO_OUT_6_START_ADDR, CTRL_FIFO_OUT_6_RD_IX_ADDR, CTRL_FIFO_OUT_6_WR_IX_ADDR, CTRL_FIFO_OUT_6_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[6], CTRL_FIFO_IN_6_START_ADDR, CTRL_FIFO_IN_6_RD_IX_ADDR, CTRL_FIFO_IN_6_WR_IX_ADDR, CTRL_FIFO_IN_6_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[7], CTRL_FIFO_OUT_7_START_ADDR, CTRL_FIFO_OUT_7_RD_IX_ADDR, CTRL_FIFO_OUT_7_WR_IX_ADDR, CTRL_FIFO_OUT_7_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[7], CTRL_FIFO_IN_7_START_ADDR, CTRL_FIFO_IN_7_RD_IX_ADDR, CTRL_FIFO_IN_7_WR_IX_ADDR, CTRL_FIFO_IN_7_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[8], CTRL_FIFO_OUT_8_START_ADDR, CTRL_FIFO_OUT_8_RD_IX_ADDR, CTRL_FIFO_OUT_8_WR_IX_ADDR, CTRL_FIFO_OUT_8_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[8], CTRL_FIFO_IN_8_START_ADDR, CTRL_FIFO_IN_8_RD_IX_ADDR, CTRL_FIFO_IN_8_WR_IX_ADDR, CTRL_FIFO_IN_8_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[9], CTRL_FIFO_OUT_9_START_ADDR, CTRL_FIFO_OUT_9_RD_IX_ADDR, CTRL_FIFO_OUT_9_WR_IX_ADDR, CTRL_FIFO_OUT_9_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[9], CTRL_FIFO_IN_9_START_ADDR, CTRL_FIFO_IN_9_RD_IX_ADDR, CTRL_FIFO_IN_9_WR_IX_ADDR, CTRL_FIFO_IN_9_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[10], CTRL_FIFO_OUT_10_START_ADDR, CTRL_FIFO_OUT_10_RD_IX_ADDR, CTRL_FIFO_OUT_10_WR_IX_ADDR, CTRL_FIFO_OUT_10_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[10], CTRL_FIFO_IN_10_START_ADDR, CTRL_FIFO_IN_10_RD_IX_ADDR, CTRL_FIFO_IN_10_WR_IX_ADDR, CTRL_FIFO_IN_10_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[11], CTRL_FIFO_OUT_11_START_ADDR, CTRL_FIFO_OUT_11_RD_IX_ADDR, CTRL_FIFO_OUT_11_WR_IX_ADDR, CTRL_FIFO_OUT_11_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[11], CTRL_FIFO_IN_11_START_ADDR, CTRL_FIFO_IN_11_RD_IX_ADDR, CTRL_FIFO_IN_11_WR_IX_ADDR, CTRL_FIFO_IN_11_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[12], CTRL_FIFO_OUT_12_START_ADDR, CTRL_FIFO_OUT_12_RD_IX_ADDR, CTRL_FIFO_OUT_12_WR_IX_ADDR, CTRL_FIFO_OUT_12_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[12], CTRL_FIFO_IN_12_START_ADDR, CTRL_FIFO_IN_12_RD_IX_ADDR, CTRL_FIFO_IN_12_WR_IX_ADDR, CTRL_FIFO_IN_12_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[13], CTRL_FIFO_OUT_13_START_ADDR, CTRL_FIFO_OUT_13_RD_IX_ADDR, CTRL_FIFO_OUT_13_WR_IX_ADDR, CTRL_FIFO_OUT_13_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[13], CTRL_FIFO_IN_13_START_ADDR, CTRL_FIFO_IN_13_RD_IX_ADDR, CTRL_FIFO_IN_13_WR_IX_ADDR, CTRL_FIFO_IN_13_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[14], CTRL_FIFO_OUT_14_START_ADDR, CTRL_FIFO_OUT_14_RD_IX_ADDR, CTRL_FIFO_OUT_14_WR_IX_ADDR, CTRL_FIFO_OUT_14_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[14], CTRL_FIFO_IN_14_START_ADDR, CTRL_FIFO_IN_14_RD_IX_ADDR, CTRL_FIFO_IN_14_WR_IX_ADDR, CTRL_FIFO_IN_14_SIZE);

	init_ctrl_fifo_hdlr(&ctrl_fifo_output[15], CTRL_FIFO_OUT_15_START_ADDR, CTRL_FIFO_OUT_15_RD_IX_ADDR, CTRL_FIFO_OUT_15_WR_IX_ADDR, CTRL_FIFO_OUT_15_SIZE);
	init_ctrl_fifo_hdlr(&ctrl_fifo_input[15], CTRL_FIFO_IN_15_START_ADDR, CTRL_FIFO_IN_15_RD_IX_ADDR, CTRL_FIFO_IN_15_WR_IX_ADDR, CTRL_FIFO_IN_15_SIZE);

	// init video input fifo.
	init_ctrl_fifo_hdlr(&input_data, INPUT_FILE_START_ADDR, INPUT_FILE_RD_IX_ADDR, INPUT_FILE_WR_IX_ADDR, INPUT_FILE_SIZE);
}

int copyVData(int bytesToCopy){
	return source_readNBytes(input_data.fifo.contents, bytesToCopy);
}

void writeData(){
	int bytesRead;
	int bytesToCopy;

	 /* Open the encoded video file */
	source_init();

	fileSize = source_sizeOfFile();
	bytesToCopy = fileSize;

//	do {
//		rd_ctrl_fifo(&ctrl_fifo_output[0]);
//	} while (1 > ctrl_fifo_output[0].fifo.size - ctrl_fifo_output[0].ctrl_fifo_wr_ix + ctrl_fifo_output[0].ctrl_fifo_rd_ix);

	while(bytesToCopy > rd_output_ctrl_fifo_nb_free(&input_data));

	bytesRead = copyVData(bytesToCopy);
	if(bytesRead == bytesToCopy){
		xil_printf("%d bytes of %d were copied.\n\r", bytesRead, fileSize);
		input_data.fifo.write_ind[0] += bytesRead;
	}else{
		xil_printf("Incomplete copy : only %d bytes of %d were copied.\n\r", bytesRead, fileSize);
		exit(-1);
	}

	source_close();
}

/*
 * Initialize AXI Performance Monitor.
 */
int init_apm(XAxiPmon *AxiPmonInstPtr, u16 DeviceID, u8 Metric)
{
	int Status;
	XAxiPmon_Config *ConfigPtr;
	u8 SlotId = 0x0;

	ConfigPtr = XAxiPmon_LookupConfig(DeviceID);
	if (ConfigPtr == NULL) {
		return XST_FAILURE;
	}

	XAxiPmon_CfgInitialize(AxiPmonInstPtr, ConfigPtr, ConfigPtr->BaseAddress);

//	XAxiPmon_EnableIDFilter(AxiPmonInstPtr);
	XAxiPmon_DisableIDFilter(AxiPmonInstPtr);

	/*
	 * Self Test the System Monitor/ADC device
	 */
	Status = XAxiPmon_SelfTest(AxiPmonInstPtr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Select Agent and required set of Metrics for a Counter.
	 * We can select another agent,Metrics for another counter by
	 * calling below function again.
	 */
	for (SlotId = 0; SlotId < ConfigPtr->NumberofSlots; SlotId++) {
		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, Metric, SlotId);
//		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, XAPM_METRIC_SET_1, XAPM_METRIC_COUNTER_1);
//		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, XAPM_METRIC_SET_2, XAPM_METRIC_COUNTER_2);
//		XAxiPmon_SetMetrics(AxiPmonInstPtr, SlotId, XAPM_METRIC_SET_3, XAPM_METRIC_COUNTER_3);
	}


	/*
	 * Enable interrupts and if APM_1
	 */
//	if(DeviceID == XPAR_MBCLUSTER1_AXI_PERF_MON_0_DEVICE_ID){
//		XAxiPmon_IntrGlobalEnable(AxiPmonInstPtr);									// Enable Global Interrupt.
//		XAxiPmon_WriteReg(AxiPmonInstPtr->Config.BaseAddress, XAPM_IE_OFFSET, 2);	// Enable Sample Interval Counter Overflow Interrupt.
//		XAxiPmon_SetSampleInterval(AxiPmonInstPtr, 10000000); 						// Write the load value in the Sample Interval Register (1 s).
//		XAxiPmon_WriteReg(AxiPmonInstPtr->Config.BaseAddress, XAPM_SICR_OFFSET, 2);	// Set the Load bit in the Sample Interval Control Register.
//		XAxiPmon_EnableSampleIntervalCounter(AxiPmonInstPtr);						// Enable the Sample Interval Counter.
//	}

	/*
	 * Enable Metric Counters.
	 */
	XAxiPmon_EnableMetricsCounter(AxiPmonInstPtr);

	/*
	 * Enable Global Clock Counter Register.
	 */
	XAxiPmon_EnableGlobalClkCounter(AxiPmonInstPtr);

	return XST_SUCCESS;

}


void readPerfMonitor(XAxiPmon *AxiPmonInstPtr,
					u32 Metrics[],
					u32 *ClkCntHigh,
					u32 *ClkCntLow){

	u8 SlotId = 0x0;
	/*
	 * Disable Global Clock Counter Register.
	 */

	XAxiPmon_DisableGlobalClkCounter(AxiPmonInstPtr);

	/*
	 * Disable Metric Counters.
	 */
//	XAxiPmon_DisableMetricsCounter(AxiPmonInstPtr);

	/* Get Metric Counters  */
	for (SlotId = 0; SlotId < AxiPmonInstPtr->Config.NumberofSlots; SlotId++) {
		Metrics[SlotId] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, SlotId);
//		Metrics[SlotId][1] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, XAPM_METRIC_COUNTER_1);
//		Metrics[SlotId][2] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, XAPM_METRIC_COUNTER_2);
//		Metrics[SlotId][3] = XAxiPmon_GetMetricCounter(AxiPmonInstPtr, XAPM_METRIC_COUNTER_3);

//		Incrementers[SlotId][0] = XAxiPmon_GetIncrementer(AxiPmonInstPtr, XAPM_INCREMENTER_0);
	}

	/* Get Global Clock Cycles Count in ClkCntHigh,ClkCntLow */
	XAxiPmon_GetGlobalClkCounter(AxiPmonInstPtr, ClkCntHigh, ClkCntLow);


}

void printFifo(u8 cpuId, fifo_u8_t* fifo, int index){
	int i;
	if(fifo->readers_nb > 1){
		xil_printf("CPU %d...fifo_%d: %d", cpuId, index, *fifo->write_ind);
		for (i = 0; i < fifo->readers_nb; i++) {
			xil_printf(" %d", fifo->read_inds[i]);
		}
		xil_printf("\n");
	}
	else{
		xil_printf("CPU %d...fifo_%d: %d %d\n", cpuId, index, *fifo->write_ind, fifo->read_inds[0]);
	}
}

void printFifoIndices(u8 cpuId){
	printFifo(cpuId, (fifo_u8_t*)&fifo_0, 0);
	printFifo(cpuId, (fifo_u8_t*)&fifo_1, 1);
	printFifo(cpuId, (fifo_u8_t*)&fifo_2, 2);
	printFifo(cpuId, (fifo_u8_t*)&fifo_3, 3);
	printFifo(cpuId, (fifo_u8_t*)&fifo_4, 4);
	printFifo(cpuId, (fifo_u8_t*)&fifo_5, 5);
	printFifo(cpuId, (fifo_u8_t*)&fifo_6, 6);
	printFifo(cpuId, (fifo_u8_t*)&fifo_7, 7);
	printFifo(cpuId, (fifo_u8_t*)&fifo_8, 8);
	printFifo(cpuId, (fifo_u8_t*)&fifo_9, 9);
	printFifo(cpuId, (fifo_u8_t*)&fifo_10, 10);
	printFifo(cpuId, (fifo_u8_t*)&fifo_11, 11);
	printFifo(cpuId, (fifo_u8_t*)&fifo_12, 12);
	printFifo(cpuId, (fifo_u8_t*)&fifo_13, 13);
	printFifo(cpuId, (fifo_u8_t*)&fifo_14, 14);
	printFifo(cpuId, (fifo_u8_t*)&fifo_15, 15);
	printFifo(cpuId, (fifo_u8_t*)&fifo_16, 16);
	printFifo(cpuId, (fifo_u8_t*)&fifo_17, 17);
	printFifo(cpuId, (fifo_u8_t*)&fifo_18, 18);
	printFifo(cpuId, (fifo_u8_t*)&fifo_19, 19);
	printFifo(cpuId, (fifo_u8_t*)&fifo_20, 20);
	printFifo(cpuId, (fifo_u8_t*)&fifo_21, 21);
	printFifo(cpuId, (fifo_u8_t*)&fifo_22, 22);
	printFifo(cpuId, (fifo_u8_t*)&fifo_23, 23);
	printFifo(cpuId, (fifo_u8_t*)&fifo_24, 24);
	printFifo(cpuId, (fifo_u8_t*)&fifo_25, 25);
	printFifo(cpuId, (fifo_u8_t*)&fifo_26, 26);
	printFifo(cpuId, (fifo_u8_t*)&fifo_27, 27);
	printFifo(cpuId, (fifo_u8_t*)&fifo_28, 28);
	printFifo(cpuId, (fifo_u8_t*)&fifo_29, 29);
	printFifo(cpuId, (fifo_u8_t*)&fifo_30, 30);
	printFifo(cpuId, (fifo_u8_t*)&fifo_31, 31);
	xil_printf("----------------------------------------\n");
}


void printMetricValues(XAxiPmon *AxiPmonInstPtr, u8 nbSlots, u8 Metric){
	u8 SlotId;
	u32 ClkCntHigh;
	u32 ClkCntLow;
	u32 Metrics[MAX_NUM_MONITOR_SLOTS] = {0};

	readPerfMonitor(AxiPmonInstPtr, Metrics, &ClkCntHigh, &ClkCntLow);
	for (SlotId = 0; SlotId < nbSlots; SlotId++) {
//		xil_printf("***APM_%d***\r\n", AxiPmonInstPtr->Config.DeviceId);
		xil_printf("%s for slot %d : %d\r\n", XAxiPmon_GetMetricName(Metric), SlotId, Metrics[SlotId]);
	}
}


void broadcastFlushMsg_blocking(int nbProcessors){
	int i;
	u8 msg;
	for (i = 0; i < nbProcessors; i++) {
		sendCtrlMsgType(&ctrl_fifo_output[i], MSG_FLUSH_DCACHE);
	}

	for (i = 0; i < nbProcessors; i++) {
		msg = rcvCtrlMsgType_blocking(&ctrl_fifo_input[i]);
		if(msg != MSG_FLUSH_DCACHE_DONE){
			xil_printf("Received message %d while expecting %d\n\r", msg, MSG_FLUSH_DCACHE_DONE);
			exit(-1);
		}
	}
}

void dynamicMapping(int nbProcessors){
	int i, j;
	int tempSchedCaller[NB_ACTORS];
	int cntr = 0;
	for (i = 0; i < nbProcessors; i++) {
		cntr = 0;
		for (j = 0; j < NB_ACTORS; j++) {
			if(mapping[nbProcessors - 1][i][j] == true){
//				tempSchedCaller[cntr] = schedCallerAddr[j];
				tempSchedCaller[cntr] = actors[j];
				cntr++;
			}
		}
		if (cntr > 0){
			sendCtrlMsgType_blocking(&ctrl_fifo_output[i], MSG_ACTORS_MAP);
			push_contents_output_ctrl_fifo_blocking(&ctrl_fifo_output[i], (u8*)tempSchedCaller, cntr * sizeof(int));
		}
	}
}

unsigned char changeMapping(void)
{
	char receivedChar = 0;
	while(!XUartPs_IsReceiveData(UART_BASEADDR));
	receivedChar = inbyte();
//		if(((receivedChar == 0x31) || (receivedChar == 0x32) || (receivedChar == 0x34) || (receivedChar == 0x38) || (receivedChar == 0x40)) && ((receivedChar - 0x30) != currNbProc)){
	prevNbProc = currNbProc;
	switch (receivedChar - 0x30) {
		case 0:
			currNbProc = 1;
			break;
		case 1:
			currNbProc = 2;
			break;
		case 2:
			currNbProc = 4;
			break;
		case 3:
			currNbProc = 8;
			break;
		case 4:
			currNbProc = 16;
			break;
	}
	if(currNbProc != prevNbProc)
//			currNbProc = receivedChar - 0x30;
//			currNbProc = 2 << (receivedChar - 0x30);
			return 1;
	else
		return 0;
}


int main(int argc, char *argv[]){

	u16 nbFrm = 0;
	u8* decPictureBuffer;

	/* Initializing control FIFOs */
	initCtrlFIFOs();

	/* Initializing .bss section to 0*/
	initMemRegion(0x20049d60, 0x19dcc);

#if ENABLE_FIFOS_COPY == 1
	initMemRegion(FIFOS_COPY_BUFFS_START_ADDR, sizeof(FIFOS_COPY_BUFF)*NB_FIFOS);
#endif

#if ENABLE_START_SIGNAL == 1
#if DDR_DATA_FIFO == 1
	/* Initializing memory region for data fifos */
	initMemRegion(DDR_DATA_FIFO_START, DDR_DATA_FIFO_SIZE);
#endif

	/* Sending start signal to all slave processors */
	if(sendStartSignalToAll() > 0) return -1;
#endif

#if USE_PERF_MON == 1
	int Status;
	/* Initializing the AXI Performance Monitors*/

//	Status = init_apm(&AxiPmonInst, XPAR_AXI_PERF_MON_0_DEVICE_ID, XAPM_METRIC_SET_0);
//	if (Status != XST_SUCCESS) {
//		xil_printf("APM System initialization failed.\r\n");
//		return XST_FAILURE;
//	}
//	XAxiPmon_SetMetrics(&AxiPmonInst, 0, XAPM_METRIC_SET_1, 2);
//	XAxiPmon_SetMetrics(&AxiPmonInst, 1, XAPM_METRIC_SET_1, 3);


	Status = init_apm(&AxiPmonInst_00, XPAR_AXIPMON_0_DEVICE_ID, XAPM_METRIC_SET_1);
	if (Status != XST_SUCCESS) {
		xil_printf("APM_0 Cluster_1 initialization failed.\r\n");
		return XST_FAILURE;
	}
	Status = init_apm(&AxiPmonInst_10, XPAR_AXIPMON_2_DEVICE_ID, XAPM_METRIC_SET_1);
	if (Status != XST_SUCCESS) {
		xil_printf("APM_0 Cluster_2 initialization failed.\r\n");
		return XST_FAILURE;
	}
//	Status = init_apm(&AxiPmonInst_01, XPAR_MBCLUSTER1_AXI_PERF_MON_1_DEVICE_ID, XAPM_METRIC_SET_1);
//	if (Status != XST_SUCCESS) {
//		xil_printf("APM_1 Cluster_1 initialization failed.\r\n");
//		return XST_FAILURE;
//	}
//	Status = init_apm(&AxiPmonInst_11, XPAR_MBCLUSTER2_AXI_PERF_MON_1_DEVICE_ID, XAPM_METRIC_SET_1);
//	if (Status != XST_SUCCESS) {
//		xil_printf("APM_1 Cluster_2 initialization failed.\r\n");
//		return XST_FAILURE;
//	}
	/*****/
#endif


	/* Initializes the SD card controller. */
	FRESULT rc = initSD();
	if(rc != FR_OK){
		xil_printf("Error %u mounting file system\n\r", rc);
		exit(-1);
	}

	/* Initializes the HDMI controller system */
	initHDMI();

	/* Writing input data into microblaze 0's local memory*/
	writeData();

	init_mappings();
//	initSchedCallerAddr();

	xil_printf("Executing with %d processor(s)\n\r", currNbProc);
	dynamicMapping(currNbProc); // Parameter nbProc; Mapping nbProc - 1, nbProc processors.

	xil_printf("0 : Execution with 1 processor(s)\n\r");
	xil_printf("1 : Execution with 2 processor(s)\n\r");
	xil_printf("2 : Execution with 4 processor(s)\n\r");
	xil_printf("3 : Execution with 8 processor(s)\n\r");
	xil_printf("4 : Execution with 16 processor(s)\n\r");
	xil_printf("Enter a value between 0 and 4: ");

//		cmpFifosWithTraces();
		while(1){
#if ENABLE_TRACES == 1
			u8 msg;
			char proc;
			TVerifyDataFifo fifoArray;
			for (proc = 0; proc < currNbProc; proc++) {
				msg = rcvCtrlMsgType(&ctrl_fifo_input[proc]);
				switch (msg) {
					case MSG_VERIFY_DATA_FIFOS:
						while(pop_contents_input_ctrl_fifo_contents_ex(&ctrl_fifo_input[proc], (u8*)&fifoArray, sizeof(TVerifyDataFifo))){
							if(verifyDataFifoVsTraces(&fifoArray) != -1){
								sendCtrlMsgType(&ctrl_fifo_output[proc], MSG_VERIFY_DATA_FIFOS_ERROR);
							}
						}
						sendCtrlMsgType(&ctrl_fifo_output[proc], MSG_VERIFY_DATA_FIFOS_OK);
						break;
					default:
						break;
				}
			}
#endif
//			printFifoIndices(XPAR_CPU_ID);
			if(changeMapping()){
//				printFifoIndices(XPAR_CPU_ID);
#if USE_PERF_MON == 1
				// Print metric values for each slot on PMon 00
				printMetricValues(&AxiPmonInst_00, XPAR_AXIPMON_0_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);

				// Print metric values for each slot on PMon 10
				printMetricValues(&AxiPmonInst_10, XPAR_AXIPMON_1_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);

			//	// Print metric values for each slot on PMon 01
			//	printMetricValues(&AxiPmonInst_01, XPAR_AXIPMON_2_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);
			//
			//	// Print metric values for each slot on PMon 11
			//	printMetricValues(&AxiPmonInst_11, XPAR_AXIPMON_3_NUM_MONITOR_SLOTS, XAPM_METRIC_SET_1);
				//	/******/
#endif
				broadcastFlushMsg_blocking(prevNbProc); // Sending flush messages and waiting for flush completed msg from all active processors.

				xil_printf("Executing with %d processor(s)\n\r", currNbProc);
				dynamicMapping(currNbProc);

//				xil_printf("0 : Execution with 1 processor(s)\n\r");
//				xil_printf("1 : Execution with 2 processor(s)\n\r");
//				xil_printf("2 : Execution with 4 processor(s)\n\r");
//				xil_printf("3 : Execution with 8 processor(s)\n\r");
//				xil_printf("4 : Execution with 16 processor(s)\n\r");
				xil_printf("Enter a value between 0 and 4: ");
			}
		}
//		while(rd_ctrl_fifo_nb_elements(&ctrl_fifo_input[0]) == 0);
//
//		source_readRefFrm(refFrmBuff);	// Read frame from reference file.
//		if(rd_ctrl_fifo_nb_elements(&ctrl_fifo_input[0]) >= IMG_LENGTH){
////				pictureBuffer = &ctrl_fifo_input[0].fifo.contents[ctrl_fifo_input[0].ctrl_fifo_rd_ix % ctrl_fifo_input[0].fifo.size];
//			decPictureBuffer = pop_ctrl_fifo_contents(&ctrl_fifo_input[0]); // Points to the contents of FIFO_0 where the image was stored.
//			DDRVideoWr(decPictureBuffer); // Copy image into the video IP frame buffer.
////				DDRVideoWr(refFrmBuff);
//			nbFrm++; // Counts the number of frames.
//			xil_printf("%d\r\n", nbFrm);
//		}

	return 0;
}
